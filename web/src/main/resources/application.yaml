server:
  port: 8080

spring:
  application:
    name: eventstream-nexus

  threads:
    virtual:
      enabled: true

  datasource:
    url: jdbc:postgresql://localhost:5432/eventstream?currentSchema=eventstream
    username: eventstream_app
    password: ${EVENTSTREAM_APP_PASSWORD}

    hikari:
      pool-name: EventStream-HikariPool

      # Virtual-thread optimized settings
      maximum-pool-size: 10        # virtual threads don't block, so keep this low
      minimum-idle: 2
      idle-timeout: 30000          # 30s
      max-lifetime: 1800000        # 30m (Postgres-friendly)
      connection-timeout: 2000     # 2s fail-fast
      validation-timeout: 1000     # 1s
      leak-detection-threshold: 0  # disable unless debugging

      # PostgreSQL recommended
      auto-commit: false
      connection-test-query: "SELECT 1"

  kafka:
    bootstrap-servers: localhost:9092
    producer:
      key-serializer: org.apache.kafka.common.serialization.StringSerializer
      value-serializer: io.confluent.kafka.serializers.KafkaAvroSerializer
      properties:
        schema.registry.url: http://localhost:8081
    consumer:
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      value-deserializer: io.confluent.kafka.serializers.KafkaAvroDeserializer
      properties:
        schema.registry.url: http://localhost:8081

logging:
  level:
    root: INFO
    org.springframework.web: INFO
    org.hibernate.SQL: DEBUG
    org.hibernate.orm.jdbc.bind: INFO
    nl.leomoot.eventstreamnexus: DEBUG

management:
  endpoints:
    web:
      exposure:
        include: health, info, metrics
  endpoint:
    health:
      probes:
        enabled: true

mapstruct:
  unmappedTargetPolicy: ERROR
  unmappedSourcePolicy: ERROR
  defaultComponentModel: spring

shedlock:
  enabled: true
  default-lock-at-most-for: 10m
  default-lock-at-least-for: 0s
  table-name: shedlock

scheduling:
  cleanup:
    cron: "0 */5 * * * *"
    lock-at-most-for: 5m
    lock-at-least-for: 1m
    retention-days: 7

